#include "xaxidma.h"
#include "xparameters.h"
#include "xil_printf.h"
#include "xil_cache.h"
#include "xstatus.h"
#include "xil_io.h"
#include <stdint.h>
//#include "lwip/init.h"
#include "lwip/udp.h"
#include "lwip/ip_addr.h"
#include "netif/xadapter.h"


// ================== 설정 상수 ==================

#define DMA_DEV_ID          XPAR_AXIDMA_0_DEVICE_ID

// AD7960 (Vref = 4.096 V, 18bit twos-complement)
#define ADC_VREF_MV         5000
#define ADC_FS_DIV          131072

// 프레임당 샘플 수 (Verilog wrapper 의 FRAME_SAMPLES=8 과 같게)
#define FRAME_SAMPLES       8U
#define BYTES_PER_SAMPLE    4U
#define FRAME_BYTE_LEN      (FRAME_SAMPLES * BYTES_PER_SAMPLE) // 32 bytes

// DDR 버퍼 베이스 주소 (더블버퍼: A/B 두 개 사용)
#define RX_BUFFER_BASE_A    0x01000000U
#define RX_BUFFER_BASE_B    (RX_BUFFER_BASE_A + FRAME_BYTE_LEN)

// ================== 전역 변수 ==================

static XAxiDma AxiDma;

// ================== 유틸: ADC 코드/전압 변환 ==================

// raw(32bit) 안에 하위 18비트만 유효 (AD7960 twos-complement)
static int32_t adc_code_from_raw(u32 raw)
{
    u32 code18 = raw & 0x3FFFFU;      // 18비트만 취함

    // bit17 (0x20000)이 부호비트 → sign extend
    // 방법 1: 수동 sign-extend
#if 1
    if (code18 & 0x20000U) {
        // 음수 → 상위 비트 1로 채우기
        return (int32_t)(code18 | ~0x3FFFFU);
    } else {
        return (int32_t)code18;
    }
#else
    // 방법 2: 시프트로 sign-extend (같은 결과)
    int32_t s = (int32_t)(code18 << 14); // bit17 → bit31
    s >>= 14;                            // 산술 시프트
    return s;
#endif
}

static int32_t adc_code_to_mv(int32_t code)
{
    // code → mV (int64_t 로 중간 계산, 오버플로 방지)
    int64_t tmp = (int64_t)code * (int64_t)ADC_VREF_MV;
    tmp /= (int64_t)ADC_FS_DIV;
    return (int32_t)tmp;
}

// ================== DMA 초기화/제어 함수 ==================

static int init_dma(void)
{
    int Status;
    XAxiDma_Config *CfgPtr;

    xil_printf("Initializing DMA...\r\n");

    CfgPtr = XAxiDma_LookupConfig(DMA_DEV_ID);
    if (CfgPtr == NULL) {
        xil_printf("No DMA config found!\r\n");
        return XST_FAILURE;
    }

    Status = XAxiDma_CfgInitialize(&AxiDma, CfgPtr);
    if (Status != XST_SUCCESS) {
        xil_printf("DMA init failed! status = %d\r\n", Status);
        return XST_FAILURE;
    }

    if (XAxiDma_HasSg(&AxiDma)) {
        xil_printf("Error: DMA is in SG mode! Need Simple mode.\r\n");
        return XST_FAILURE;
    }

    xil_printf("DMA init OK.\r\n");
    xil_printf("DMA Base Address = 0x%08lx\r\n", AxiDma.RegBase);

    return XST_SUCCESS;
}

// S2MM 채널 리셋 + 에러 플래그 클리어
static void reset_s2mm(void)
{
    xil_printf("Resetting S2MM channel...\r\n");

    // 기존 에러 플래그 있으면 모두 클리어
    u32 sr = XAxiDma_ReadReg(
                 AxiDma.RegBase + XAXIDMA_RX_OFFSET,
                 XAXIDMA_SR_OFFSET);
    if (sr & XAXIDMA_ERR_ALL_MASK) {
        XAxiDma_WriteReg(
            AxiDma.RegBase + XAXIDMA_RX_OFFSET,
            XAXIDMA_SR_OFFSET,
            sr | XAXIDMA_ERR_ALL_MASK);
        xil_printf("S2MM Error flags cleared.\r\n");
    }

    XAxiDma_Reset(&AxiDma);
    while (!XAxiDma_ResetIsDone(&AxiDma)) {
        // busy wait
    }

    xil_printf("S2MM reset done.\r\n");
}

// 버퍼 하나에 대해 S2MM 전송 시작
static int start_dma_receive(u32 buf_base)
{
    u32 Status;

    xil_printf("Starting DMA receive: buf=0x%08lx, len=%lu bytes\r\n",
               buf_base, (u32)FRAME_BYTE_LEN);

    // DMA가 새 데이터를 쓸 것이므로, CPU 캐시 라인 무효화
    Xil_DCacheInvalidateRange(buf_base, FRAME_BYTE_LEN);

    Status = XAxiDma_SimpleTransfer(
                 &AxiDma,
                 (UINTPTR)buf_base,
                 (u32)FRAME_BYTE_LEN,
                 XAXIDMA_DEVICE_TO_DMA);

    if (Status != XST_SUCCESS) {
        xil_printf("XAxiDma_SimpleTransfer failed! status=%lu\r\n", Status);
        return XST_FAILURE;
    }

    return XST_SUCCESS;
}

// S2MM 완료 대기 + 에러 체크
static int wait_for_dma_done(void)
{
    xil_printf("Waiting for DMA to finish...\r\n");

    while (1) {
        u32 s2mm_sr = XAxiDma_ReadReg(
                          AxiDma.RegBase + XAXIDMA_RX_OFFSET,
                          XAXIDMA_SR_OFFSET);

        // 에러 비트 체크
        if (s2mm_sr & XAXIDMA_ERR_ALL_MASK) {
            // 에러 발생 시 플래그 클리어
            XAxiDma_WriteReg(
                AxiDma.RegBase + XAXIDMA_RX_OFFSET,
                XAXIDMA_SR_OFFSET,
                s2mm_sr | XAXIDMA_ERR_ALL_MASK);

            xil_printf("DMA error! S2MM_DMASR=0x%08lx\r\n", s2mm_sr);
            return XST_FAILURE;
        }

        // Busy 비트가 0이면 완료
        if (!XAxiDma_Busy(&AxiDma, XAXIDMA_DEVICE_TO_DMA)) {
            xil_printf("DMA completed. S2MM_DMASR=0x%08lx\r\n", s2mm_sr);
            break;
        }
    }

    return XST_SUCCESS;
}

// ================== 수신한 프레임 처리 ==================

static void print_frame_debug(u32 buf_base, u32 frame_index)
{
    u32 *buf = (u32 *)buf_base;

    xil_printf("Frame %lu, %d samples (raw/code/mV):\r\n",
               frame_index, (int)FRAME_SAMPLES);

    for (u32 i = 0; i < FRAME_SAMPLES; i++) {
        u32 raw      = buf[i];
        int32_t code = adc_code_from_raw(raw);
        int32_t mv   = adc_code_to_mv(code);

        // int32_t → %d 로 출력 (LP64 환경에서도 안전)
        xil_printf("[%2lu] raw=0x%08lx  code=%7d  Vdiff=%4d mV\r\n",
                   i, raw, (int)code, (int)mv);
    }
}

static void handle_frame(u32 buf_base, u32 frame_index)
{
    // DMA가 DDR에 쓴 후 CPU가 읽으므로, 읽기 전에 캐시 무효화
    Xil_DCacheInvalidateRange(buf_base, FRAME_BYTE_LEN);

    print_frame_debug(buf_base, frame_index);

    // 나중에 여기에서 UDP 송신 붙이면 됨
    // send_frame_udp((const u8 *)buf_base, (u16)FRAME_BYTE_LEN);
}

// 디버깅용: DMA 시작 전에 패턴 채우기
static void fill_buffer_pattern(u32 buf_base)
{
    u32 *buf = (u32 *)buf_base;
    xil_printf("Filling RX buffer with pattern 0xAAAAAAAA ...\r\n");

    for (u32 i = 0; i < FRAME_SAMPLES; i++) {
        buf[i] = 0xAAAAAAAAU;
    }
    // CPU가 쓴 패턴이 DDR에 반영되도록 Flush
    Xil_DCacheFlushRange(buf_base, FRAME_BYTE_LEN);
}

// ================== main: 반복 DMA + 더블 버퍼 루프 ==================

int main(void)
{
    int Status;

    xil_printf("==== AD7960 + AXI DMA continuous capture test (FRAME_SAMPLES=%d) ====\r\n",
               (int)FRAME_SAMPLES);

    Status = init_dma();
    if (Status != XST_SUCCESS) {
        xil_printf("init_dma failed\r\n");
        return XST_FAILURE;
    }

    // DMA는 초기 1회만 리셋 + 에러 클리어
    reset_s2mm();

    // 더블 버퍼를 번갈아 사용
    u32 cur_buf     = RX_BUFFER_BASE_A;
    u32 frame_index = 0;

    while (1) {
        xil_printf("\r\n--- Start frame %lu, buffer 0x%08lx ---\r\n",
                   frame_index, cur_buf);

        fill_buffer_pattern(cur_buf);

        Status = start_dma_receive(cur_buf);
        if (Status != XST_SUCCESS) {
            xil_printf("start_dma_receive failed\r\n");
            break;
        }

        Status = wait_for_dma_done();
        if (Status != XST_SUCCESS) {
            xil_printf("wait_for_dma_done failed\r\n");
            break;
        }

        handle_frame(cur_buf, frame_index);

        // 다음 프레임에서는 버퍼 A/B 스왑
        if (cur_buf == RX_BUFFER_BASE_A) {
            cur_buf = RX_BUFFER_BASE_B;
        } else {
            cur_buf = RX_BUFFER_BASE_A;
        }

        frame_index++;
    }

    xil_printf("Exiting main due to error.\r\n");
    return XST_FAILURE;
}
